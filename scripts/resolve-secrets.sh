#!/bin/bash
# resolve-secrets.sh - Resolve mcpd secrets into an environment file for Docker/k8s.
#
# This script reads the environment contract (.env file) generated by `mcpd config export`
# and resolves matching secrets from the GitHub Actions secrets context into an output file.
#
# Usage:
#   SECRETS_JSON='...' ./scripts/resolve-secrets.sh [contract-file] [output-file]
#
# Arguments:
#   contract-file  Path to the .env contract file (default: .env)
#   output-file    Path to write resolved secrets (default: .env.resolved)
#
# Environment:
#   SECRETS_JSON   JSON object containing GitHub secrets (from ${{ toJSON(secrets) }})
#   DEPLOY_ENV     Optional deployment environment name (e.g. production)
#   VERBOSE        Set to "true" for debug logging

set -euo pipefail

# --- Configuration ---
CONTRACT_FILE="${1:-.env}"
OUTPUT_FILE="${2:-.env.resolved}"
VERBOSE="${VERBOSE:-false}"

# --- Counters ---
RESOLVED=0
MISSING=0

# --- Functions ---

log_debug() {
  if [[ "$VERBOSE" == "true" ]]; then
    printf "[DEBUG] %s\n" "$1"
  fi
}

print_usage() {
  echo "Usage: $0 [contract-file] [output-file]"
  echo "  contract-file  Path to the .env contract file (default: .env)"
  echo "  output-file    Path to write resolved secrets (default: .env.resolved)"
}

validate_inputs() {
  if [[ $# -gt 2 ]]; then
    echo "::error ::Too many arguments."
    print_usage
    exit 1
  fi

  if [[ ! -f "$CONTRACT_FILE" ]]; then
    echo "::error ::Contract file not found: $CONTRACT_FILE"
    exit 1
  fi

  if [[ -z "${SECRETS_JSON:-}" ]]; then
    echo "::error ::SECRETS_JSON environment variable is not set"
    exit 1
  fi
}

extract_variables() {
  grep '^MCPD__' "$CONTRACT_FILE" 2>/dev/null | cut -d= -f1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sort -u || true
}

print_expected_secrets() {
  local vars="$1"
  echo ""
  if [[ -n "${DEPLOY_ENV:-}" ]]; then
    printf "Expected secrets for '%s' (configure in GitHub repository secrets):\n" "$DEPLOY_ENV"
  else
    echo "Expected secrets (configure in GitHub repository secrets):"
  fi
  for var in $vars; do
    printf "  - %s\n" "$var"
  done
  echo ""
}

resolve_secret() {
  local var="$1"

  log_debug "Attempting to resolve: $var"

  if jq -e --arg key "$var" '.[$key]' <<< "$SECRETS_JSON" > /dev/null 2>&1; then
    local value
    value=$(jq -r --arg key "$var" '.[$key]' <<< "$SECRETS_JSON")
    printf "Resolved: %s\n" "$var"
    # Single-quote value and escape embedded single quotes.
    # This prevents shell interpretation of $, `, \, etc.
    local escaped_value="${value//\'/\'\\\'\'}"
    printf "%s='%s'\n" "$var" "$escaped_value" >> "$OUTPUT_FILE"
    RESOLVED=$((RESOLVED + 1))
  else
    if [[ -n "${DEPLOY_ENV:-}" ]]; then
      echo "::warning ::Variable $var required for '$DEPLOY_ENV' but not found in GitHub Secrets."
    else
      echo "::warning ::Variable $var required by mcpd but not found in GitHub Secrets."
    fi
    MISSING=$((MISSING + 1))
  fi
}

print_summary() {
  echo "--- Summary ---"
  printf "Resolved: %d variable(s) -> %s\n" "$RESOLVED" "$OUTPUT_FILE"
  printf "Missing:  %d variable(s)\n" "$MISSING"

  if [[ $MISSING -gt 0 ]]; then
    if [[ -n "${DEPLOY_ENV:-}" ]]; then
      echo "::notice ::Some mcpd secrets for '$DEPLOY_ENV' are missing. Ensure they are configured in repository secrets."
    else
      echo "::notice ::Some mcpd secrets are missing. Ensure they are configured in repository secrets."
    fi
  fi
}

# --- Main ---

main() {
  validate_inputs "$@"

  printf -- "--- Resolving GitHub secrets required for mcpd (%s) ---\n" "$CONTRACT_FILE"

  local vars
  vars=$(extract_variables)

  if [[ -z "$vars" ]]; then
    echo "No mcpd prefixed variables (MCPD__) found in contract file."
    exit 0
  fi

  log_debug "Found variables: $vars"

  print_expected_secrets "$vars"

  # Clear output file and set restrictive permissions.
  # 600 ensures only the owner (runner user) can read the secrets.
  # Docker's --env-file reads via the client (same user), so this is safe.
  : > "$OUTPUT_FILE"
  chmod 600 "$OUTPUT_FILE"

  for var in $vars; do
    resolve_secret "$var"
  done

  print_summary
}

main "$@"
