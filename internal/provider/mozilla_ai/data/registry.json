{
  "airtable": {
    "arguments": {
      "AIRTABLE_API_KEY": {
        "description": "Airtable API key for database access",
        "example": "keyXXXXXXXXXXXXXX",
        "name": "AIRTABLE_API_KEY",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Databases"],
    "description": "Airtable database and spreadsheet operations for managing bases, tables, and records",
    "displayName": "Airtable",
    "homepage": "https://github.com/felores/airtable-mcp",
    "id": "airtable",
    "installations": {
      "npx": {
        "description": "Run with npx",
        "package": "@felores/airtable-mcp-server",
        "recommended": true,
        "runtime": "npx",
        "version": "0.3.0"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "airtable",
    "publisher": {
      "name": "Felipe Restrepo"
    },
    "tags": [
      "airtable",
      "data management",
      "database",
      "records",
      "spreadsheet"
    ],
    "tools": [
      {
        "description": "Create a new record in an Airtable table",
        "name": "create_record"
      },
      {
        "description": "Retrieve records from an Airtable table",
        "name": "get_records"
      },
      {
        "description": "List all accessible Airtable bases",
        "name": "list_bases"
      },
      {
        "description": "List tables in an Airtable base",
        "name": "list_tables"
      }
    ],
    "transports": ["stdio"]
  },
  "duckduckgo-mcp": {
    "arguments": {},
    "categories": ["Web Services"],
    "description": "Web search capabilities using DuckDuckGo with additional features for content fetching and parsing",
    "displayName": "DuckDuckGo Search",
    "homepage": "https://github.com/nickclyde/duckduckgo-mcp-server",
    "id": "duckduckgo-mcp",
    "installations": {
      "uvx": {
        "description": "Run with Python uvx",
        "package": "duckduckgo-mcp-server",
        "recommended": true,
        "runtime": "uvx",
        "version": "0.1.1"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "duckduckgo-mcp",
    "publisher": {
      "name": "Nick Clyde",
      "url": "https://clyde.tech"
    },
    "tags": ["content fetching", "duckduckgo", "search engine", "web search"],
    "tools": [
      {
        "description": "Fetch and parse content from a webpage URL",
        "name": "fetch_content"
      },
      {
        "description": "Search DuckDuckGo and return formatted results",
        "name": "search"
      }
    ],
    "transports": ["stdio"]
  },
  "elasticsearch": {
    "arguments": {
      "ELASTIC_HOST": {
        "description": "Elasticsearch server host URL",
        "example": "https://localhost:9200",
        "name": "ELASTIC_HOST",
        "required": true,
        "type": "environment"
      },
      "ELASTIC_PASSWORD": {
        "description": "Password for Elasticsearch authentication",
        "example": "changeme",
        "name": "ELASTIC_PASSWORD",
        "required": true,
        "type": "environment"
      },
      "ELASTIC_USERNAME": {
        "description": "Username for Elasticsearch authentication",
        "example": "elastic",
        "name": "ELASTIC_USERNAME",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Databases"],
    "description": "Elasticsearch and OpenSearch integration for searching documents, analyzing indices, and managing clusters",
    "displayName": "Elasticsearch",
    "homepage": "https://github.com/cr7258/elasticsearch-mcp-server",
    "id": "elasticsearch",
    "installations": {
      "uvx": {
        "description": "Run with Python uvx",
        "package": "elasticsearch-mcp-server",
        "recommended": true,
        "runtime": "uvx",
        "version": "2.0.10"
      }
    },
    "isOfficial": false,
    "license": "Apache-2.0",
    "name": "elasticsearch",
    "publisher": {
      "name": "cr7258"
    },
    "tags": [
      "analytics",
      "cluster management",
      "elasticsearch",
      "opensearch",
      "search"
    ],
    "tools": [
      {
        "description": "Create a new index",
        "name": "create_index"
      },
      {
        "description": "Delete an alias",
        "name": "delete_alias"
      },
      {
        "description": "Delete documents matching a query",
        "name": "delete_by_query"
      },
      {
        "description": "Delete a document by ID",
        "name": "delete_document"
      },
      {
        "description": "Delete an index",
        "name": "delete_index"
      },
      {
        "description": "Perform a general HTTP API request",
        "name": "general_api_request"
      },
      {
        "description": "Get alias information",
        "name": "get_alias"
      },
      {
        "description": "Get cluster health status",
        "name": "get_cluster_health"
      },
      {
        "description": "Get cluster statistics",
        "name": "get_cluster_stats"
      },
      {
        "description": "Get a document by ID",
        "name": "get_document"
      },
      {
        "description": "Get index information",
        "name": "get_index"
      },
      {
        "description": "Create or update a document",
        "name": "index_document"
      },
      {
        "description": "List all aliases",
        "name": "list_aliases"
      },
      {
        "description": "List all indices in the Elasticsearch cluster",
        "name": "list_indices"
      },
      {
        "description": "Create or update an alias",
        "name": "put_alias"
      },
      {
        "description": "Search documents in an index with a custom query",
        "name": "search_documents"
      }
    ],
    "transports": ["stdio"]
  },
  "filesystem": {
    "arguments": {
      "ALLOWED_DIRS": {
        "description": "Additional allowed directories for file operations",
        "example": "/path/to/another/allowed/directory",
        "name": "ALLOWED_DIRS",
        "position": 2,
        "required": false,
        "type": "argument_positional"
      },
      "DIRECTORY_PATH": {
        "description": "The directory path where the server can operate",
        "example": "/path/to/working/directory",
        "name": "DIRECTORY_PATH",
        "position": 1,
        "required": true,
        "type": "argument_positional"
      }
    },
    "categories": ["System Tools"],
    "description": "Secure file operations with configurable access controls for reading, writing, and managing files and directories",
    "displayName": "Filesystem",
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem",
    "id": "filesystem",
    "installations": {
      "docker": {
        "description": "Run with Docker",
        "package": "mcp/filesystem",
        "recommended": true,
        "runtime": "docker",
        "version": "latest"
      },
      "npm": {
        "description": "Run with npm",
        "package": "@modelcontextprotocol/server-filesystem",
        "runtime": "npx",
        "version": "2025.7.29"
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "filesystem",
    "publisher": {
      "name": "Anthropic, PBC",
      "url": "https://anthropic.com"
    },
    "tags": [
      "directory management",
      "file operations",
      "filesystem",
      "secure access"
    ],
    "tools": [
      {
        "description": "Create a new directory or ensure a directory exists",
        "name": "create_directory"
      },
      {
        "description": "Get a detailed listing of all files and directories in a specified path",
        "name": "list_directory"
      },
      {
        "description": "Read the complete contents of a file from the file system",
        "name": "read_file"
      },
      {
        "description": "Recursively search for files and directories matching a pattern",
        "name": "search_files"
      },
      {
        "description": "Create a new file or completely overwrite an existing file with new content",
        "name": "write_file"
      }
    ],
    "transports": ["stdio"]
  },
  "gitlab": {
    "arguments": {
      "GITLAB_API_URL": {
        "description": "GitLab API URL (for self-hosted instances)",
        "example": "https://gitlab.example.com/api/v4",
        "name": "GITLAB_API_URL",
        "required": false,
        "type": "environment"
      },
      "GITLAB_PERSONAL_ACCESS_TOKEN": {
        "description": "GitLab personal access token for API authentication",
        "example": "glpat-xxxxxxxxxxxxxxxxxxxx",
        "name": "GITLAB_PERSONAL_ACCESS_TOKEN",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Development"],
    "description": "GitLab API integration for project management and repository operations",
    "displayName": "GitLab",
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/gitlab",
    "id": "gitlab",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "@modelcontextprotocol/server-gitlab",
        "recommended": true,
        "runtime": "npx",
        "version": "2025.4.25"
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "gitlab",
    "publisher": {
      "name": "GitLab, PBC",
      "url": "https://gitlab.com"
    },
    "tags": [
      "git",
      "gitlab",
      "project management",
      "repository",
      "version control"
    ],
    "tools": [
      {
        "description": "Create a new issue in a GitLab project",
        "name": "create_issue"
      },
      {
        "description": "Get details of a specific GitLab project",
        "name": "get_project"
      },
      {
        "description": "List issues for a GitLab project",
        "name": "list_issues"
      },
      {
        "description": "List GitLab projects accessible to the user",
        "name": "list_projects"
      }
    ],
    "transports": ["stdio"]
  },
  "google-maps": {
    "arguments": {
      "GOOGLE_MAPS_API_KEY": {
        "description": "Google Maps API key from Google Developers Console",
        "example": "AIzaSyXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        "name": "GOOGLE_MAPS_API_KEY",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Web Services"],
    "description": "Location services, directions, and place details using Google Maps API",
    "displayName": "Google Maps",
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/google-maps",
    "id": "google-maps",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "@modelcontextprotocol/server-google-maps",
        "recommended": true,
        "runtime": "npx",
        "version": "0.6.2"
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "google-maps",
    "publisher": {
      "name": "Anthropic, PBC",
      "url": "https://anthropic.com"
    },
    "tags": ["directions", "geocoding", "google maps", "location", "places"],
    "tools": [
      {
        "description": "Get directions between two points",
        "name": "maps_directions"
      },
      {
        "description": "Convert an address into geographic coordinates",
        "name": "maps_geocode"
      },
      {
        "description": "Convert coordinates into an address",
        "name": "maps_reverse_geocode"
      },
      {
        "description": "Search for places using Google Places API",
        "name": "maps_search_places"
      }
    ],
    "transports": ["stdio"]
  },
  "jira": {
    "arguments": {
      "--confluence-token": {
        "description": "Confluence API token",
        "example": "ATATT3xFfGF0...",
        "name": "--confluence-token",
        "required": true,
        "type": "argument"
      },
      "--confluence-url": {
        "description": "Confluence server URL",
        "example": "https://your-domain.atlassian.net",
        "name": "--confluence-url",
        "required": true,
        "type": "argument"
      },
      "--confluence-username": {
        "description": "Confluence username or email",
        "example": "user@example.com",
        "name": "--confluence-username",
        "required": true,
        "type": "argument"
      },
      "--jira-token": {
        "description": "Jira API token",
        "example": "ATATT3xFfGF0...",
        "name": "--jira-token",
        "required": true,
        "type": "argument"
      },
      "--jira-url": {
        "description": "Jira server URL",
        "example": "https://your-domain.atlassian.net",
        "name": "--jira-url",
        "required": true,
        "type": "argument"
      },
      "--jira-username": {
        "description": "Jira username or email",
        "example": "user@example.com",
        "name": "--jira-username",
        "required": true,
        "type": "argument"
      }
    },
    "categories": ["Productivity"],
    "description": "Atlassian integration for Jira project management and Confluence documentation with comprehensive API access",
    "displayName": "Atlassian Jira & Confluence",
    "homepage": "https://github.com/sooperset/mcp-atlassian",
    "id": "jira",
    "installations": {
      "uvx": {
        "description": "Run with Python uvx",
        "package": "mcp-atlassian",
        "recommended": true,
        "runtime": "uvx",
        "version": "0.11.9"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "jira",
    "publisher": {
      "name": "sooperset"
    },
    "tags": [
      "atlassian",
      "confluence",
      "documentation",
      "jira",
      "project management"
    ],
    "tools": [
      {
        "description": "Add a comment to a Confluence page",
        "name": "confluence_add_comment"
      },
      {
        "description": "Add a label to a Confluence page",
        "name": "confluence_add_label"
      },
      {
        "description": "Create a new Confluence page",
        "name": "confluence_create_page"
      },
      {
        "description": "Delete a Confluence page",
        "name": "confluence_delete_page"
      },
      {
        "description": "Get comments from a Confluence page",
        "name": "confluence_get_comments"
      },
      {
        "description": "Get content of a specific Confluence page",
        "name": "confluence_get_page"
      },
      {
        "description": "Get the child pages of a specific Confluence page",
        "name": "confluence_get_page_children"
      },
      {
        "description": "Get labels on a Confluence page",
        "name": "confluence_get_labels"
      },
      {
        "description": "Search Confluence content using CQL",
        "name": "confluence_search"
      },
      {
        "description": "Search Confluence users",
        "name": "confluence_search_user"
      },
      {
        "description": "Update an existing Confluence page",
        "name": "confluence_update_page"
      },
      {
        "description": "Add a comment to a Jira issue",
        "name": "jira_add_comment"
      },
      {
        "description": "Add a worklog entry to a Jira issue",
        "name": "jira_add_worklog"
      },
      {
        "description": "Create multiple Jira issues in batch",
        "name": "jira_batch_create_issues"
      },
      {
        "description": "Create multiple Jira project versions in batch",
        "name": "jira_batch_create_versions"
      },
      {
        "description": "Create a new Jira issue",
        "name": "jira_create_issue"
      },
      {
        "description": "Create a new Jira issue link",
        "name": "jira_create_issue_link"
      },
      {
        "description": "Create a new Jira sprint",
        "name": "jira_create_sprint"
      },
      {
        "description": "Create a new Jira project version",
        "name": "jira_create_version"
      },
      {
        "description": "Delete a Jira issue",
        "name": "jira_delete_issue"
      },
      {
        "description": "Download attachments from a Jira issue",
        "name": "jira_download_attachments"
      },
      {
        "description": "Get all Jira agile boards",
        "name": "jira_get_agile_boards"
      },
      {
        "description": "Get all Jira projects",
        "name": "jira_get_all_projects"
      },
      {
        "description": "Get issues from a Jira board",
        "name": "jira_get_board_issues"
      },
      {
        "description": "Get details of a specific Jira issue",
        "name": "jira_get_issue"
      },
      {
        "description": "Get all Jira issue link types",
        "name": "jira_get_issue_link_types"
      },
      {
        "description": "Get details of a Jira user profile",
        "name": "jira_get_user_profile"
      },
      {
        "description": "Get versions of a Jira project",
        "name": "jira_get_project_versions"
      },
      {
        "description": "Get all issues in a Jira project",
        "name": "jira_get_project_issues"
      },
      {
        "description": "Get sprints from a Jira board",
        "name": "jira_get_sprints_from_board"
      },
      {
        "description": "Get issues from a Jira sprint",
        "name": "jira_get_sprint_issues"
      },
      {
        "description": "Get possible transitions for a Jira issue",
        "name": "jira_get_transitions"
      },
      {
        "description": "Get worklog details of a Jira issue",
        "name": "jira_get_worklog"
      },
      {
        "description": "Link a Jira issue to an epic",
        "name": "jira_link_to_epic"
      },
      {
        "description": "Remove an existing Jira issue link",
        "name": "jira_remove_issue_link"
      },
      {
        "description": "Search available Jira fields",
        "name": "jira_search_fields"
      },
      {
        "description": "Transition a Jira issue to a new status",
        "name": "jira_transition_issue"
      },
      {
        "description": "Update an existing Jira issue",
        "name": "jira_update_issue"
      },
      {
        "description": "Update an existing Jira sprint",
        "name": "jira_update_sprint"
      }
    ],
    "transports": ["stdio"]
  },
  "mcp-discord": {
    "arguments": {
      "DISCORD_TOKEN": {
        "description": "Discord bot token for authentication",
        "example": "YOUR_DISCORD_BOT_TOKEN_HERE",
        "name": "DISCORD_TOKEN",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Messaging"],
    "description": "Discord messaging and server management with comprehensive channel, message, and webhook capabilities",
    "displayName": "Discord Integration",
    "homepage": "https://github.com/barryyip0625/mcp-discord",
    "id": "mcp-discord",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "mcp-discord",
        "recommended": true,
        "runtime": "npx",
        "version": "1.3.4"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "mcp-discord",
    "publisher": {
      "name": "Barry Yip"
    },
    "tags": ["bot", "channel management", "discord", "messaging", "webhook"],
    "tools": [
      {
        "description": "Add an emoji reaction to a Discord message",
        "name": "discord_add_reaction"
      },
      {
        "description": "Create a new text channel in a Discord server",
        "name": "discord_create_text_channel"
      },
      {
        "description": "Retrieve messages from a Discord text channel",
        "name": "discord_read_messages"
      },
      {
        "description": "Send a message to a specified Discord text channel",
        "name": "discord_send"
      }
    ],
    "transports": ["stdio"]
  },
  "memory": {
    "arguments": {
      "MEMORY_FILE_PATH": {
        "description": "Path to the memory storage JSON file",
        "example": "/path/to/memory.json",
        "name": "MEMORY_FILE_PATH",
        "required": false,
        "type": "environment"
      }
    },
    "categories": ["Knowledge Base"],
    "description": "Knowledge graph-based persistent memory system for storing and retrieving contextual information",
    "displayName": "Knowledge Graph Memory",
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/memory",
    "id": "memory",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "@modelcontextprotocol/server-memory",
        "recommended": true,
        "runtime": "npx",
        "version": "2025.8.4"
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "memory",
    "publisher": {
      "name": "Anthropic, PBC",
      "url": "https://anthropic.com"
    },
    "tags": ["context", "knowledge graph", "memory", "persistent storage"],
    "tools": [
      {
        "description": "Create multiple new entities in the knowledge graph",
        "name": "create_entities"
      },
      {
        "description": "Create relations between entities in the knowledge graph",
        "name": "create_relations"
      },
      {
        "description": "Search for nodes in the knowledge graph",
        "name": "search_nodes"
      }
    ],
    "transports": ["stdio"]
  },
  "monday-api-mcp": {
    "arguments": {
      "--token": {
        "description": "API key for authenticating with the Monday.com API.",
        "example": "your-monday-api-key",
        "name": "--token",
        "required": true,
        "type": "argument"
      },
      "--version": {
        "description": "monday.com API version",
        "example": "current",
        "name": "--version",
        "required": false,
        "type": "argument"
      },
      "--read-only": {
        "description": "Enable read-only mode",
        "name": "--read-only",
        "required": false,
        "type": "argument_bool"
      },
      "--enable-dynamic-api-tools": {
        "description": "Enable dynamic API tools",
        "name": "--enable-dynamic-api-tools",
        "required": false,
        "type": "argument_bool"
      }
    },
    "categories": ["Productivity"],
    "description": "A server implementation for the Model Context Protocol (MCP) that provides an interface to interact with Monday.com API.",
    "displayName": "Monday.com API MCP Server",
    "homepage": "https://github.com/mondaycom/mcp",
    "id": "monday-api-mcp",
    "installations": {
      "npx": {
        "description": "Run with npm and dynamic API tools",
        "package": "@mondaydotcomorg/monday-api-mcp",
        "recommended": true,
        "runtime": "npx",
        "version": "1.4.2",
        "repository": {
          "type": "git",
          "url": "https://github.com/mondaycom/mcp/tree/master/packages/monday-api-mcp"
        }
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "monday-api-mcp",
    "publisher": {
      "name": "Monday.com",
      "url": "https://monday.com"
    },
    "tags": [
      "monday.com",
      "API"
    ],
    "tools": [
      {
        "name": "all_widgets_schema",
        "description": "Fetch complete JSON Schema 7 definitions for all available widget types in monday.com. This tool is essential before creating widgets as it provides: - Complete schema definitions for all supported widgets - Required and optional fields for each widget type - Data type specifications and validation rules - Detailed descriptions of widget capabilities Use this tool when you need to: - Understand widget configuration requirements before creating widgets - Validate widget settings against official schemas - Plan widget implementations with proper data structures The response includes JSON Schema 7 definitions that describe exactly what settings each widget type accepts."
      },
      {
        "name": "change_item_column_values",
        "description": "Change the column values of an item in a monday.com board"
      },
      {
        "name": "create_board",
        "description": "Create a monday.com board"
      },
      {
        "name": "create_column",
        "description": "Create a new column in a monday.com board"
      },
      {
        "name": "create_custom_activity",
        "description": "Create a new custom activity in the E&A app"
      },
      {
        "name": "create_dashboard",
        "description": "Use this tool to create a new monday.com dashboard that aggregates data from one or more boards. Dashboards provide visual representations of board data through widgets and charts. Use this tool when users want to: - Create a dashboard to visualize board data - Aggregate information from multiple boards - Set up a data visualization container for widgets"
      },
      {
        "name": "create_doc",
        "description": "Create a new monday.com doc either inside a workspace or attached to an item (via a doc column). After creation, the provided markdown will be appended to the document. LOCATION TYPES: - workspace: Creates a document in a workspace (requires workspace_id, optional doc_kind, optional folder_id) - item: Creates a document attached to an item (requires item_id, optional column_id) USAGE EXAMPLES: - Workspace doc: { location: { type: \"workspace\", workspace_id: 123, doc_kind: \"private\" }, markdown: \"...\" } - Workspace doc in folder: { location: { type: \"workspace\", workspace_id: 123, folder_id: 17264196 }, markdown: \"...\" } - Item doc: { location: { type: \"item\", item_id: 456, column_id: \"doc_col_1\" }, markdown: \"...\" }"
      },
      {
        "name": "create_folder",
        "description": "Create a new folder in a monday.com workspace"
      },
      {
        "name": "create_form",
        "description": "Create a monday.com form. This will create a new form as well as a new board for which the form’s responses will be stored. The returned board_id is the ID of the board that was created while the returned formToken can be used for all future queries and mutations to continue editing the form."
      },
      {
        "name": "create_group",
        "description": "Create a new group in a monday.com board. Groups are sections that organize related items. Use when users want to add structure, categorize items, or create workflow phases. Groups can be positioned relative to existing groups and assigned predefined colors. Items will always be created in the top group and so the top group should be the most relevant one for new item creation"
      },
      {
        "name": "create_item",
        "description": "Create a new item in a monday.com board"
      },
      {
        "name": "create_update",
        "description": "Create a new update in a monday.com board"
      },
      {
        "name": "create_timeline_item",
        "description": "Create a new timeline item in the E&A app"
      },
      {
        "name": "create_widget",
        "description": "Create a new widget in a dashboard or board view with specific configuration settings. This tool creates data visualization widgets that display information from monday.com boards: **Parent Containers:** - **DASHBOARD**: Place widget in a dashboard (most common use case) - **BOARD_VIEW**: Place widget in a specific board view **Critical Requirements:** 1. **Schema Compliance**: Widget settings MUST conform to the JSON schema for the specific widget type 2. **Use all_widgets_schema first**: Always fetch widget schemas before creating widgets 3. **Validate settings**: Ensure all required fields are provided and data types match **Workflow:** 1. Use 'all_widgets_schema' to get schema definitions 2. Prepare widget settings according to the schema 3. Use this tool to create the widget"
      },
      {
        "name": "create_workspace",
        "description": "Create a new workspace in monday.com"
      },
      {
        "name": "delete_column",
        "description": "Delete a column from a monday.com board"
      },
      {
        "name": "delete_item",
        "description": "Delete an item"
      },
      {
        "name": "fetch_custom_activity",
        "description": "Get custom activities from the E&A app"
      },
      {
        "name": "form_questions_editor",
        "description": "Create, update, or delete a question in a monday.com form"
      },
      {
        "name": "get_board_activity",
        "description": "Get board activity logs for a specified time range (defaults to last 30 days)"
      },
      {
        "name": "get_board_info",
        "description": "Get comprehensive board information including metadata, structure, owners, and configuration"
      },
      {
        "name": "get_board_items_by_name",
        "description": "Get items by board id and term"
      },
      {
        "name": "get_board_schema",
        "description": "Get board schema (columns and groups) by board id"
      },
      {
        "name": "get_column_type_info",
        "description": "Retrieves comprehensive information about a specific column type, including JSON schema definition and other metadata. Use this before creating columns with the create_column tool to understand the structure, validation rules, and available properties for column settings."
      },
      {
        "name": "get_form",
        "description": "Get a monday.com form by its form token. Form tokens can be extracted from the form’s url. Given a form url, such as https://forms.monday.com/forms/abc123def456ghi789?r=use1, the token is the alphanumeric string that appears right after /forms/ and before the ?. In the example, the token is abc123def456ghi789."
      },
      {
        "name": "get_users_by_name",
        "description": "Get users, can be filtered by name or partial name"
      },
      {
        "name": "list_users_and_teams",
        "description": "PRECISION-FIRST user and team retrieval tool. AI agents MUST prioritize specific queries over broad searches. MANDATORY BEST PRACTICES: 1. ALWAYS use specific IDs when available (userIds, teamIds) - highest precision and performance 2. ALWAYS use name search when you have user names but no IDs 3. ALWAYS use boolean getMe: true when requesting current user information 4. AVOID broad queries (no parameters) - use only as absolute last resort 5. COMBINE parameters strategically to minimize API calls REQUIRED PARAMETER PRIORITY (use in this order): 1. getMe: true (when requesting current user) - STANDALONE ONLY 2. name=\"exact_name\" (when searching by name) - STANDALONE ONLY 3. userIds=[\"id1\",\"id2\"] (when you have specific user IDs) 4. teamIds=[\"id1\",\"id2\"] + teamsOnly: true (when you have specific team IDs) 5. No parameters (LAST RESORT - fetches up to 1000 users, avoid unless absolutely necessary) CRITICAL USAGE RULES: • getMe and name parameters CANNOT be combined with any other parameters • userIds + teamIds requires explicit includeTeams: true flag • teamsOnly: true prevents user data fetching (teams-only queries) • includeTeamMembers: true adds detailed member data to teams • includeTeams: true fetches both users and teams, do not use this to fetch a specific user's teams rather fetch that user by id and you will get their team memberships. OPTIMIZATION DIRECTIVES: • NEVER fetch all users when specific IDs are available • NEVER use broad queries for single user/team lookups • ALWAYS prefer name search over ID-less queries for individual users • SET includeTeamMembers: false for team lists, true only for member analysis • AVOID includeTeams: true unless you specifically need both users AND teams • AVOID broad queries for single user/team, if you have specific IDs, use them. For example getting a user's teams, use that user's ID and fetch their team using the includeTeams flag. RESPONSE CONTENT: • Users: id, name, email, title, permissions, contact details, team memberships • Teams: id, name, owners, members (when includeTeamMembers: true) • Current user: id, name, title, enabled, is_admin, is_guest (basic profile only)"
      },
      {
        "name": "list_workspaces",
        "description": "List all workspaces available to the user. Returns up to 500 workspaces with their ID, name, and description."
      },
      {
        "name": "move_item_to_group",
        "description": "Move an item to a group in a monday.com board"
      },
      {
        "name": "move_object",
        "description": "Move a folder, board, or overview in monday.com. Use `position` for relative placement based on another object, `parentFolderId` for folder changes, `workspaceId` for workspace moves, and `accountProductId` for account product changes."
      },
      {
        "name": "read_docs",
        "description": "Get a collection of monday.com documents with their content as markdown. PAGINATION: - Default limit is 25 documents per page - Use 'page' parameter to get additional pages (starts at 1) - Check response for 'has_more_pages' to know if you should continue paginating - If user asks for \"all documents\" and you get exactly 25 results, continue with page 2, 3, etc. FILTERING: Provide an ID filter object with: - type: 'ids' for specific document IDs - type: 'object_ids' for specific document object IDs - type: 'workspace_ids' for all docs in specific workspaces - values: array of ID strings (at least 1 required) Examples: - { type: 'ids', values: ['123', '456'] } - { type: 'object_ids', values: ['123'] } - { type: 'workspace_ids', values: ['ws_101'] } USAGE PATTERNS: - For specific documents: use type 'ids' or 'object_ids' (A monday doc has two unique identifiers) - For workspace exploration: use type 'workspace_ids' with pagination - For large searches: start with page 1, then paginate if has_more_pages=true"
      },
      {
        "name": "update_folder",
        "description": "Update an existing folder in monday.com"
      },
      {
        "name": "update_form",
        "description": "Update a monday.com form. Handles the following form update actions that can only be done one at a time using the correct \"action\" input: - update form's feature settings with the action \"updateFeatures\", - update form's appearance settings with the action \"updateAppearance\", - update form's accessibility settings with the action \"updateAccessibility\", - update form's title with the action \"updateFormHeader\", - update form's description with the action \"updateFormHeader\", - update form's question order with the action \"updateQuestionOrder\", - create a new form tag with the action \"createTag\", - delete a form tag with the action \"deleteTag\", - update a form tag with the action \"updateTag\", - set or update the form's password with the action \"setFormPassword\" - shorten form's url with the action \"shortenFormUrl\" - deactivate form with the action \"deactivateForm\" - reactivate form with the action \"activateForm\""
      },
      {
        "name": "update_workspace",
        "description": "Update an existing workspace in monday.com"
      },
      {
        "name": "workspace_info",
        "description": "This tool returns the boards, docs and folders in a workspace and which folder they are in. It returns up to 100 of each object type, if you receive 100 assume there are additional objects of that type in the workspace."
      }
    ],
    "transports": ["stdio"]
  },
  "notion": {
    "arguments": {
      "NOTION_API_KEY": {
        "description": "Notion API key for workspace access",
        "example": "secret_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        "name": "NOTION_API_KEY",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Productivity"],
    "description": "Official Notion integration for page management, database operations, and content creation",
    "displayName": "Notion Workspace",
    "homepage": "https://github.com/makenotion/notion-mcp-server",
    "id": "notion",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "@notionhq/notion-mcp-server",
        "recommended": true,
        "runtime": "npx",
        "version": "1.8.1"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "notion",
    "publisher": {
      "name": "Notion Labs, Inc.",
      "url": "https://notion.so"
    },
    "tags": ["content management", "database", "notion", "pages", "workspace"],
    "tools": [
      {
        "description": "Retrieve a user",
        "name": "API-get-user"
      },
      {
        "description": "List all users",
        "name": "API-get-users"
      },
      {
        "description": "Retrieve your token's bot user",
        "name": "API-get-self"
      },
      {
        "description": "Query a database",
        "name": "API-post-database-query"
      },
      {
        "description": "Search by title",
        "name": "API-post-search"
      },
      {
        "description": "Retrieve block children",
        "name": "API-get-block-children"
      },
      {
        "description": "Append block children",
        "name": "API-patch-block-children"
      },
      {
        "description": "Retrieve a block",
        "name": "API-retrieve-a-block"
      },
      {
        "description": "Update a block",
        "name": "API-update-a-block"
      },
      {
        "description": "Delete a block",
        "name": "API-delete-a-block"
      },
      {
        "description": "Retrieve a page",
        "name": "API-retrieve-a-page"
      },
      {
        "description": "Update page properties",
        "name": "API-patch-page"
      },
      {
        "description": "Create a page",
        "name": "API-post-page"
      },
      {
        "description": "Create a database",
        "name": "API-create-a-database"
      },
      {
        "description": "Update a database",
        "name": "API-update-a-database"
      },
      {
        "description": "Retrieve a database",
        "name": "API-retrieve-a-database"
      },
      {
        "description": "Retrieve a page property item",
        "name": "API-retrieve-a-page-property"
      },
      {
        "description": "Retrieve comments",
        "name": "API-retrieve-a-comment"
      },
      {
        "description": "Create comment",
        "name": "API-create-a-comment"
      }
    ],
    "transports": ["stdio"]
  },
  "perplexity": {
    "arguments": {
      "PERPLEXITY_API_KEY": {
        "description": "API key for Perplexity Sonar API",
        "example": "pplx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        "name": "PERPLEXITY_API_KEY",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Web Services"],
    "description": "AI-powered search and information retrieval using Perplexity's Sonar API for real-time web research",
    "displayName": "Perplexity AI Search",
    "homepage": "https://github.com/ppl-ai/modelcontextprotocol",
    "id": "perplexity",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "server-perplexity-ask",
        "recommended": true,
        "runtime": "npx",
        "version": "0.1.3"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "perplexity",
    "publisher": {
      "name": "Perplexity AI",
      "url": "https://perplexity.ai"
    },
    "tags": [
      "ai search",
      "information retrieval",
      "perplexity",
      "sonar api",
      "web research"
    ],
    "tools": [
      {
        "description": "Engage in a conversation using the Sonar API for AI-powered search",
        "name": "perplexity_ask"
      }
    ],
    "transports": ["stdio"]
  },
  "slack-mcp": {
    "arguments": {
      "SLACK_BOT_TOKEN": {
        "description": "Slack bot token for authentication",
        "example": "xoxb-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        "name": "SLACK_BOT_TOKEN",
        "required": true,
        "type": "environment"
      },
      "SLACK_CHANNEL_IDS": {
        "description": "Comma-separated list of channel IDs to monitor",
        "example": "general,random,development",
        "name": "SLACK_CHANNEL_IDS",
        "required": false,
        "type": "environment"
      },
      "SLACK_TEAM_ID": {
        "description": "Slack team/workspace ID",
        "example": "T0123456789",
        "name": "SLACK_TEAM_ID",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Messaging"],
    "description": "Slack workspace integration for comprehensive channel, message, reaction and user management",
    "displayName": "Slack Workspace",
    "homepage": "https://github.com/zencoderai/slack-mcp-server",
    "id": "slack-mcp",
    "installations": {
      "npm": {
        "description": "Run with npm",
        "package": "@zencoderai/slack-mcp-server",
        "recommended": true,
        "runtime": "npx",
        "version": "0.0.1"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "slack-mcp",
    "publisher": {
      "name": "Zencoder AI",
      "url": "https://zencoder.ai"
    },
    "tags": ["channels", "collaboration", "messaging", "slack", "workspace"],
    "tools": [
      {
        "description": "List public or pre-defined channels in the workspace",
        "name": "slack_list_channels"
      },
      {
        "description": "Post a new message to a Slack channel",
        "name": "slack_post_message"
      },
      {
        "description": "Reply to a specific message thread",
        "name": "slack_reply_to_thread"
      },
      {
        "description": "Add an emoji reaction to a message",
        "name": "slack_add_reaction"
      },
      {
        "description": "Get recent messages from a channel",
        "name": "slack_get_channel_history"
      },
      {
        "description": "Get all replies in a message thread",
        "name": "slack_get_thread_replies"
      },
      {
        "description": "Get list of workspace users with basic profile information",
        "name": "slack_get_users"
      },
      {
        "description": "Get detailed profile information for a specific user",
        "name": "slack_get_user_profile"
      }
    ],
    "transports": ["stdio"]
  },
  "sqlite": {
    "arguments": {
      "--db-path": {
        "description": "Path to the SQLite database file",
        "example": "~/test.db",
        "name": "--db-path",
        "required": true,
        "type": "argument"
      }
    },
    "categories": ["Databases"],
    "description": "SQLite database operations with business intelligence capabilities for querying, analyzing, and generating automated insights",
    "displayName": "SQLite Database",
    "homepage": "https://github.com/modelcontextprotocol/servers-archived/tree/main/src/sqlite",
    "id": "sqlite",
    "installations": {
      "uvx": {
        "description": "Run with Python uvx",
        "package": "mcp-server-sqlite",
        "recommended": true,
        "runtime": "uvx",
        "version": "2025.4.25"
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "sqlite",
    "publisher": {
      "name": "Model Context Protocol",
      "url": "https://modelcontextprotocol.io"
    },
    "tags": [
      "business intelligence",
      "database",
      "queries",
      "schema management",
      "sql",
      "sqlite"
    ],
    "tools": [
      {
        "description": "Add business insights to the memo resource",
        "name": "append_insight"
      },
      {
        "description": "Create new database tables",
        "name": "create_table"
      },
      {
        "description": "View detailed table schema information",
        "name": "describe_table"
      },
      {
        "description": "Get all table names in the database",
        "name": "list_tables"
      },
      {
        "description": "Execute SELECT queries on the database",
        "name": "read_query"
      },
      {
        "description": "Perform INSERT, UPDATE, DELETE operations",
        "name": "write_query"
      }
    ],
    "transports": ["stdio"]
  },
  "zim": {
    "arguments": {
      "DIRECTORY_PATH": {
        "description": "The directory path where the ZIM files are stored",
        "example": "/path/to/zimfiles/directory",
        "name": "DIRECTORY_PATH",
        "position": 1,
        "required": true,
        "type": "argument_positional"
      }
    },
    "categories": ["Knowledge Base"],
    "description": "Enable AI models to access and search ZIM format knowledge bases offline ",
    "displayName": "ZIM",
    "homepage": "https://github.com/aittalam/zim-mcp-server",
    "id": "zim",
    "installations": {
      "uvx": {
        "description": "Run with Python uvx",
        "package": "zim-mcp-server",
        "recommended": true,
        "runtime": "uvx",
        "version": "0.1.0"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "zim",
    "publisher": {
      "name": "Davide Eynard",
      "url": "https://github.com/aittalam"
    },
    "tags": [
      "knowledge base",
      "wikipedia"
    ],
    "tools": [
      {
        "description": "List all ZIM files in allowed directories",
        "name": "list_zim_files"
      },
      {
        "description": "Search within ZIM file content",
        "name": "search_zim_file"
      },
      {
        "description": "Get detailed content of a specific entry in a ZIM file",
        "name": "get_zim_entry"
      }
    ],
    "transports": ["stdio"]
  },
  "searxng": {
    "arguments": {
      "SEARXNG_URL": {
        "description": "URL of the SearXNG instance you want to send your search queries to",
        "example": "http://127.0.0.1:8080",
        "name": "SEARXNG_URL",
        "required": true,
        "type": "environment"
      }
    },
    "categories": ["Web Services"],
    "description": "Provides Web Search capabilities using the SearXNG API",
    "displayName": "SearXNG",
    "homepage": "https://github.com/ihor-sokoliuk/mcp-searxng",
    "id": "searxng",
    "installations": {
      "npx": {
        "description": "Run with npx",
        "package": "mcp-searxng",
        "recommended": true,
        "runtime": "npx",
        "version": "0.6.0"
      }
    },
    "isOfficial": false,
    "license": "MIT",
    "name": "searxng",
    "publisher": {
      "name": "ihor-sokoliuk",
      "url": "https://github.com/ihor-sokoliuk"
    },
    "tags": [
      "search engine",
      "web search",
      "content fetching"
    ],
    "tools": [
      {
        "description": "Performs a web search using the SearXNG API, ideal for general queries, news, articles, and online content. Use this for broad information gathering, recent events, or when you need diverse web sources.",
        "name": "searxng_web_search"
      },
      {
        "description": "Read the content from an URL. Use this for further information retrieving to understand the content of each URL.",
        "name": "web_url_read"
      }
    ],
    "transports": ["stdio"]
  },
  "redis": {
    "arguments": {
      "REDIS_URL": {
        "description": "Redis connection URL",
        "example": "redis://localhost:6379",
        "name": "REDIS_URL",
        "required": false,
        "type": "environment"
      }
    },
    "categories": ["Databases"],
    "description": "Redis database operations for caching, data storage, and key-value operations",
    "displayName": "Redis",
    "homepage": "https://github.com/modelcontextprotocol/servers/tree/main/src/redis",
    "id": "redis",
    "installations": {
      "docker": {
        "description": "Run with Docker",
        "package": "mcp/redis",
        "recommended": true,
        "runtime": "docker",
        "version": "latest"
      }
    },
    "isOfficial": true,
    "license": "MIT",
    "name": "redis",
    "publisher": {
      "name": "Anthropic",
      "url": "https://github.com/modelcontextprotocol"
    },
    "tags": [
      "redis",
      "database",
      "cache",
      "key-value",
      "storage"
    ],
    "tools": [
    {
      "name": "client_list",
      "description": "Get a list of connected clients to the Redis server."
    },
    {
      "name": "create_vector_index_hash",
      "description": "Create a Redis 8 vector similarity index using HNSW on a Redis hash. This function sets up a Redis index for approximate nearest neighbor (ANN) search using the HNSW algorithm and float32 vector embeddings."
    },
    {
      "name": "dbsize",
      "description": "Get the number of keys stored in the Redis database"
    },
    {
      "name": "delete",
      "description": "Delete a Redis key."
    },
    {
      "name": "expire",
      "description": "Set an expiration time for a Redis key."
    },
    {
      "name": "get",
      "description": "Get a Redis string value."
    },
    {
      "name": "get_index_info",
      "description": "Retrieve schema and information about a specific Redis index using FT.INFO."
    },
    {
      "name": "get_indexed_keys_number",
      "description": "Retrieve the number of indexed keys by the index"
    },
    {
      "name": "get_indexes",
      "description": "List of indexes in the Redis database Returns: str: A JSON string containing the list of indexes or an error message."
    },
    {
      "name": "get_vector_from_hash",
      "description": "Retrieve a vector from a Redis hash and convert it back from binary blob."
    },
    {
      "name": "hdel",
      "description": "Delete a field from a Redis hash."
    },
    {
      "name": "hexists",
      "description": "Check if a field exists in a Redis hash."
    },
    {
      "name": "hget",
      "description": "Get the value of a field in a Redis hash."
    },
    {
      "name": "hgetall",
      "description": "Get all fields and values from a Redis hash."
    },
    {
      "name": "hset",
      "description": "Set a field in a hash stored at key with an optional expiration time."
    },
    {
      "name": "info",
      "description": "Get Redis server information and statistics."
    },
    {
      "name": "json_del",
      "description": "Delete a JSON value from Redis at a given path."
    },
    {
      "name": "json_get",
      "description": "Retrieve a JSON value from Redis at a given path."
    },
    {
      "name": "json_set",
      "description": "Set a JSON value in Redis at a given path with an optional expiration time."
    },
    {
      "name": "llen",
      "description": "Get the length of a Redis list."
    },
    {
      "name": "lpop",
      "description": "Remove and return the first element from a Redis list."
    },
    {
      "name": "lpush",
      "description": "Push a value onto the left of a Redis list and optionally set an expiration time."
    },
    {
      "name": "lrange",
      "description": "Get elements from a Redis list within a specific range. Returns: str: A JSON string containing the list of elements or an error message."
    },
    {
      "name": "publish",
      "description": "Publish a message to a Redis channel."
    },
    {
      "name": "rename",
      "description": "Renames a Redis key from old_key to new_key."
    },
    {
      "name": "rpop",
      "description": "Remove and return the last element from a Redis list."
    },
    {
      "name": "rpush",
      "description": "Push a value onto the right of a Redis list and optionally set an expiration time."
    },
    {
      "name": "sadd",
      "description": "Add a value to a Redis set with an optional expiration time."
    },
    {
      "name": "scan_all_keys",
      "description": "Scan and return ALL keys matching a pattern using multiple SCAN iterations. This function automatically handles the SCAN cursor iteration to collect all matching keys. It's safer than KEYS * for large databases but will still collect all results in memory. ⚠️ WARNING: With very large datasets (millions of keys), this may consume significant memory. For large-scale operations, consider using scan_keys() with manual iteration instead."
    },
    {
      "name": "scan_keys",
      "description": "Scan keys in the Redis database using the SCAN command (non-blocking, production-safe). ⚠️ IMPORTANT: This returns PARTIAL results from one iteration. Use scan_all_keys() to get ALL matching keys, or call this function multiple times with the returned cursor until cursor becomes 0. The SCAN command iterates through the keyspace in small chunks, making it safe to use on large databases without blocking other operations."
    },
    {
      "name": "set",
      "description": "Set a Redis string value with an optional expiration time."
    },
    {
      "name": "set_vector_in_hash",
      "description": "Store a vector as a field in a Redis hash."
    },
    {
      "name": "smembers",
      "description": "Get all members of a Redis set."
    },
    {
      "name": "srem",
      "description": "Remove a value from a Redis set."
    },
    {
      "name": "subscribe",
      "description": "Subscribe to a Redis channel."
    },
    {
      "name": "type",
      "description": "Returns the string representation of the type of the value stored at key"
    },
    {
      "name": "unsubscribe",
      "description": "Unsubscribe from a Redis channel."
    },
    {
      "name": "vector_search_hash",
      "description": "Perform a KNN vector similarity search using Redis 8 or later version on vectors stored in hash data structures."
    },
    {
      "name": "xadd",
      "description": "Add an entry to a Redis stream with an optional expiration time."
    },
    {
      "name": "xdel",
      "description": "Delete an entry from a Redis stream."
    },
    {
      "name": "xrange",
      "description": "Read entries from a Redis stream."
    },
    {
      "name": "zadd",
      "description": "Add a member to a Redis sorted set with an optional expiration time."
    },
    {
      "name": "zrange",
      "description": "Retrieve a range of members from a Redis sorted set."
    },
    {
      "name": "zrem",
      "description": "Remove a member from a Redis sorted set."
    }
    ],
    "transports": ["stdio"]
  }
}
